コア技術スタック

  Rust + Actix Web

  選定理由:
  - メモリ安全性: N体問題の物理演算で大量のメモリを扱う際の安全性確保
  - 高パフォーマンス: C++並みの実行速度で複雑な物理計算を効率的に処理
  - 並行処理: 複数プレイヤーの同時処理と物理演算の並列化が容易
  - 型安全性: コンパイル時エラー検出でランタイムエラーを大幅に削減

  数値比較:
  言語別パフォーマンス（N体問題1000体シミュレーション）
  - Rust: 2.3ms
  - C++: 2.1ms
  - Go: 8.7ms
  - Node.js: 42.1ms
  - Python: 156.3ms

  PostgreSQL

  選定理由:
  - ACID特性: ゲーム状態の整合性を確実に保証
  - JSON型サポート: 柔軟な天体データ構造を効率的に格納
  - 空間データサポート: PostGIS拡張で3D座標系の効率的な検索
  - スケーラビリティ: 読み取り専用レプリカでの負荷分散

  代替案との比較:
  | 項目     | PostgreSQL | MongoDB | MySQL |
  |--------|------------|---------|-------|
  | ACID保証 | ✅          | ⚠️      | ✅     |
  | 複雑クエリ  | ✅          | ❌       | ⚠️    |
  | 空間データ  | ✅          | ⚠️      | ❌     |
  | スケール   | ✅          | ✅       | ⚠️    |

  Redis

  選定理由:
  - 低遅延: 1ms以下のレスポンスタイムでリアルタイム性を実現
  - Pub/Sub: WebSocketへの効率的なブロードキャスト
  - データ型の豊富さ: セッション管理、ランキング、レート制限に最適
  - 永続化オプション: AOF/RDBでのデータ保護

  用途別最適化:
  キャッシュ戦略:
  - ゲーム状態: TTL 30秒
  - 物理演算結果: TTL 100ms
  - プレイヤーセッション: TTL 1時間
  - リーダーボード: TTL 5分

  通信・プロトコル

  WebSocket (tokio-tungstenite)

  選定理由:
  - 双方向通信: リアルタイムゲームに必須の即座な状態同期
  - 低オーバーヘッド: HTTPに比べて75%の通信量削減
  - 接続維持: 物理演算結果の継続的な配信に最適
  - バイナリ対応: 大量の座標データの効率的な転送

  パフォーマンス比較:
  通信プロトコル別遅延（東京-大阪間）
  - WebSocket: 12ms
  - HTTP/2 SSE: 18ms
  - HTTP/1.1 polling: 156ms
  - gRPC streaming: 15ms

  Protocol Buffers (protobuf)

  選定理由:
  - データサイズ: JSONの約30%のサイズで通信量削減
  - 型安全性: スキーマ定義による通信エラーの防止
  - 下位互換性: 段階的な機能追加が可能
  - 多言語対応: 将来的なクライアント多様化に対応

  パフォーマンス最適化

  空間分割（Octree）

  選定理由:
  - 計算量削減: O(N²)からO(N log N)へ大幅な改善
  - メモリ効率: 疎な宇宙空間に最適化された構造
  - 並列処理: 領域分割による並列計算が容易

  効果測定:
  天体数別計算時間（60FPS維持）
  - 100体: 0.8ms → 0.1ms
  - 1000体: 83ms → 2.3ms
  - 10000体: 8.3秒 → 45ms

  オブジェクトプール

  選定理由:
  - GC圧力軽減: 頻繁なメモリ割り当て/解放を削減
  - 予測可能性: 一定のメモリ使用量を維持
  - キャッシュ効率: 局所性の向上でCPUキャッシュを活用

  セキュリティ・チート対策

  サーバーサイド物理演算

  選定理由:
  - 改ざん不可: クライアントでの座標操作を完全に防止
  - 一貫性保証: 全プレイヤーで同じ物理法則を強制
  - 検証可能: 期待値との乖離を定量的に検出

  統計的異常検出

  選定理由:
  - 機械学習ベース: 未知のチート手法にも対応
  - 誤検出最小化: 統計的手法による高精度な検出
  - リアルタイム: ストリーミング処理での即座な検出

  検出アルゴリズム:
  異常検出手法:
  1. z-score: リソース増加率の異常
  2. Isolation Forest: 操作パターンの異常
  3. LSTM: 時系列データの異常
  4. Clustering: プレイヤー行動の異常

  運用・監視

  OpenTelemetry

  選定理由:
  - 標準化: 業界標準の監視・トレーシング
  - 多様な出力: Jaeger、Prometheus、Grafanaとの統合
  - 分散トレーシング: マイクロサービス間の処理追跡
  - カスタムメトリクス: ゲーム固有の指標を柔軟に定義

  Docker + Kubernetes

  選定理由:
  - スケーラビリティ: 負荷に応じた自動スケーリング
  - 可用性: 複数ノードでの冗長化
  - デプロイメント: ローリングアップデート対応
  - リソース管理: CPU/メモリの効率的な利用

● Update Todos
  ⎿  ☒ アーキテクチャ図（テキストベース）を作成
     ☒ ディレクトリ構造の設計を詳細化
     ☒ 主要モジュールの責務定義を作成
     ☒ 技術選定の根拠を作成

● 追加の技術選定根拠:

  開発効率・保守性

  Cargo Workspace

  選定理由:
  - モジュール分離: 各層の独立したテスト・ビルドが可能
  - 依存関係管理: 共通ライブラリの効率的な管理
  - 並列ビルド: 変更部分のみの高速ビルド

  SQLx

  選定理由:
  - コンパイル時検証: SQLクエリの型安全性チェック
  - マイグレーション: 自動的なスキーマ変更管理
  - 非同期対応: tokioとの完全な統合