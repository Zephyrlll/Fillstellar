import * as THREE from 'three';
import { gameState, gameStateManager, GraphicsState, GRAPHICS_PRESETS, applyGraphicsPreset } from './state.js';
import { 
    scene, camera, renderer, composer, ambientLight, bloomPass,
    bokehPass, fxaaPass, filmPass, colorCorrectionPass, vignettePass
} from './threeSetup.js';
import { performanceMonitor } from './performanceMonitor.js';
import { starfieldOptimizer } from './starfieldOptimizer.js';
import { isMobileDevice } from './deviceDetection.js';

export class GraphicsEngine {
    private previousSettings: Partial<GraphicsState> = {};
    private frameRateLimiter: FrameRateLimiter;
    private lodSystems: Map<THREE.Object3D, LODSystem> = new Map();
    private dynamicQualityEnabled: boolean = false;
    private qualityAdjustmentCooldown: number = 0;
    private postProcessingEnabled: boolean = true;
    private secondaryRenderer: THREE.WebGLRenderer | null = null;
    private secondaryCamera: THREE.PerspectiveCamera | null = null;
    public isPaused: boolean = false;
    
    constructor() {
        this.frameRateLimiter = new FrameRateLimiter();
        // Don't apply settings in constructor - wait for explicit initialization
        console.log('üéÆ Graphics engine created (settings will be applied on first update)');
        
        // „Éù„Çπ„Éà„Éó„É≠„Çª„ÉÉ„Ç∑„É≥„Ç∞„ÅÆÂàùÊúüÁä∂ÊÖã„ÇíË®≠ÂÆö
        const initialGraphics = gameStateManager.getState().graphics;
        this.postProcessingEnabled = initialGraphics.postProcessing !== 'off';
        console.log(`üéÆ Post-processing initial state: ${this.postProcessingEnabled} (${initialGraphics.postProcessing})`);
        
        // „É¢„Éê„Ç§„É´„Éá„Éê„Ç§„Çπ„ÅÆËá™ÂãïÊ§úÂá∫„Å®Ë®≠ÂÆö
        this.initializeMobileOptimizations();
    }
    
    // Apply all current graphics settings
    applyAllSettings(): void {
        console.log('[GraphicsEngine] applyAllSettings() called');
        const graphics = gameStateManager.getState().graphics;
        
        this.applyResolutionScale(graphics.resolutionScale);
        this.applyAntiAliasing(graphics.antiAliasing);
        this.applyShadowQuality(graphics.shadowQuality);
        this.applyPostProcessing(graphics.postProcessing);
        this.applyViewDistance(graphics.viewDistance);
        this.applyLightingQuality(graphics.lightingQuality);
        this.applyFogEffect(graphics.fogEffect);
        this.applyRenderPrecision(graphics.renderPrecision);
        this.applyUIAnimations(graphics.uiAnimations);
        this.applyParticleDensity(graphics.particleDensity); // ËøΩÂä†ÔºÅ
        this.applyTextureQuality(graphics.textureQuality);
        this.applyObjectDetail(graphics.objectDetail);
        this.applyBackgroundDetail(graphics.backgroundDetail);
        
        // „Éì„Ç∏„É•„Ç¢„É´„Ç®„Éï„Çß„ÇØ„Éà„ÅÆÈÅ©Áî®
        if (graphics.bloom !== undefined) {
            this.applyPostProcessing(graphics.bloom);
        }
        if (graphics.depthOfField !== undefined) {
            this.applyBokehEffect({
                enabled: graphics.depthOfField !== 'off',
                focus: graphics.depthOfField === 'dynamic' ? 1000 : 2000,
                aperture: graphics.depthOfField === 'dynamic' ? 0.025 : 0.05,
                maxblur: graphics.depthOfField === 'dynamic' ? 0.01 : 0.02
            });
        }
        if (graphics.filmGrain !== undefined) {
            this.applyFilmGrainEffect({
                enabled: graphics.filmGrain,
                noiseIntensity: (graphics.filmGrainIntensity || 50) / 100 * 0.5,
                scanlinesIntensity: (graphics.filmGrainIntensity || 50) / 100 * 0.05
            });
        }
        if (graphics.toneMapping !== undefined) {
            this.applyToneMapping(graphics.toneMapping);
        }
        if (graphics.colorCorrection !== undefined) {
            this.applyColorCorrection({
                enabled: graphics.colorCorrection,
                brightness: (graphics.brightness || 100) / 100,
                contrast: (graphics.contrast || 100) / 100,
                saturation: (graphics.saturation || 100) / 100
            });
        }
        if (graphics.vignette !== undefined) {
            this.applyVignetteEffect({
                enabled: graphics.vignette,
                offset: 1.0,
                darkness: 1.0 + ((graphics.vignetteIntensity || 50) / 100 * 2.0)
            });
        }
        
        // Update frame rate limiter
        this.frameRateLimiter.setTargetFPS(graphics.frameRateLimit);
        // console.log(`üéØ Frame rate limit set to: ${graphics.frameRateLimit} FPS`);
        
        // Store current settings for change detection
        this.previousSettings = { ...graphics };
        
        // console.log(`üé® Graphics settings applied: ${graphics.preset} preset`);
    }
    
    // Check for setting changes and apply only what's needed
    update(): void {
        const graphics = gameStateManager.getState().graphics;
        
        // Debug: Log current graphics state periodically
        if (Math.random() < 0.001) { // Log occasionally to avoid spam
            console.log('[GraphicsEngine.update] Current graphics state:', graphics);
            console.log('[GraphicsEngine.update] Previous settings:', this.previousSettings);
        }
        
        // If this is the first update, apply all settings
        if (Object.keys(this.previousSettings).length === 0) {
            console.log('üéÆ Graphics engine first update - applying all settings');
            console.log('üéÆ Initial postProcessing setting:', graphics.postProcessing);
            this.applyAllSettings();
            return;
        }
        
        // Debug log
        if (this.previousSettings.resolutionScale !== graphics.resolutionScale) {
            console.log(`[GraphicsEngine.update] Previous: ${this.previousSettings.resolutionScale}, Current: ${graphics.resolutionScale}`);
        }
        
        // Check for preset changes
        if (this.previousSettings.preset !== graphics.preset && graphics.preset !== 'custom') {
            this.applyPreset(graphics.preset as keyof typeof GRAPHICS_PRESETS);
            return;
        }
        
        // Check for visual style changes
        if (this.previousSettings.visualStyle !== graphics.visualStyle && graphics.visualStyle !== 'custom') {
            console.log(`[GraphicsEngine] Visual style changed: ${this.previousSettings.visualStyle} -> ${graphics.visualStyle}`);
            this.applyVisualStyleEffects(graphics);
        }
        
        // Check individual setting changes
        if (this.previousSettings.resolutionScale !== graphics.resolutionScale) {
            console.log(`[GraphicsEngine] Resolution scale changed: ${this.previousSettings.resolutionScale} -> ${graphics.resolutionScale}`);
            this.applyResolutionScale(graphics.resolutionScale);
        }
        
        if (this.previousSettings.antiAliasing !== graphics.antiAliasing) {
            this.applyAntiAliasing(graphics.antiAliasing);
        }
        
        if (this.previousSettings.shadowQuality !== graphics.shadowQuality) {
            this.applyShadowQuality(graphics.shadowQuality);
        }
        
        if (this.previousSettings.postProcessing !== graphics.postProcessing) {
            this.applyPostProcessing(graphics.postProcessing);
        }
        
        if (this.previousSettings.viewDistance !== graphics.viewDistance) {
            this.applyViewDistance(graphics.viewDistance);
        }
        
        if (this.previousSettings.lightingQuality !== graphics.lightingQuality) {
            this.applyLightingQuality(graphics.lightingQuality);
        }
        
        if (this.previousSettings.fogEffect !== graphics.fogEffect) {
            this.applyFogEffect(graphics.fogEffect);
        }
        
        if (this.previousSettings.frameRateLimit !== graphics.frameRateLimit) {
            this.frameRateLimiter.setTargetFPS(graphics.frameRateLimit);
        }
        
        if (this.previousSettings.particleDensity !== graphics.particleDensity) {
            console.log('[GraphicsEngine] Particle density changed from', this.previousSettings.particleDensity, 'to', graphics.particleDensity);
            this.applyParticleDensity(graphics.particleDensity);
        }
        
        if (this.previousSettings.textureQuality !== graphics.textureQuality) {
            this.applyTextureQuality(graphics.textureQuality);
        }
        
        if (this.previousSettings.objectDetail !== graphics.objectDetail) {
            this.applyObjectDetail(graphics.objectDetail);
        }
        
        if (this.previousSettings.backgroundDetail !== graphics.backgroundDetail) {
            this.applyBackgroundDetail(graphics.backgroundDetail);
        }
        
        // Update LOD systems
        this.updateLODSystems();
        
        // Handle dynamic quality adjustment
        if (this.dynamicQualityEnabled) {
            this.handleDynamicQuality();
        }
        
        // Store current settings
        this.previousSettings = { ...graphics };
    }
    
    // Apply a graphics preset
    applyPreset(presetName: keyof typeof GRAPHICS_PRESETS): void {
        const currentState = gameStateManager.getState();
        const newGraphics = applyGraphicsPreset(currentState.graphics, presetName);
        
        // Update the state with the new graphics settings
        gameStateManager.updateState(state => ({
            ...state,
            graphics: newGraphics
        }));
        
        this.applyAllSettings();
        performanceMonitor.resetHistory();
        console.log(`üé® Applied graphics preset: ${presetName}`);
    }
    
    // Resolution scaling
    applyResolutionScale(scale: number): void {
        console.log(`[GraphicsEngine] Applying resolution scale: ${scale}`);
        const canvas = renderer.domElement;
        const pixelRatio = window.devicePixelRatio || 1;
        
        // Ë°®Á§∫„Çµ„Ç§„Ç∫ÔºàÂ∏∏„Å´ÁîªÈù¢„ÅÑ„Å£„Å±„ÅÑÔºâ
        const displayWidth = window.innerWidth;
        const displayHeight = window.innerHeight;
        
        // ÂÜÖÈÉ®„É¨„É≥„ÉÄ„É™„É≥„Ç∞Ëß£ÂÉèÂ∫¶ÔºàÂìÅË≥™„Å´ÂΩ±ÈüøÔºâ
        const renderWidth = Math.round(displayWidth * scale);
        const renderHeight = Math.round(displayHeight * scale);
        
        console.log(`[GraphicsEngine] === Resolution Scale Debug ===`);
        console.log(`[GraphicsEngine] Scale: ${scale} (${scale * 100}%)`);
        console.log(`[GraphicsEngine] Window size: ${displayWidth}x${displayHeight}`);
        console.log(`[GraphicsEngine] Target render size: ${renderWidth}x${renderHeight}`);
        console.log(`[GraphicsEngine] Pixel ratio: ${pixelRatio}`);
        console.log(`[GraphicsEngine] Before - Canvas internal size: ${canvas.width}x${canvas.height}`);
        console.log(`[GraphicsEngine] Before - Canvas CSS size: ${canvas.style.width}x${canvas.style.height}`);
        
        // === „É¨„É≥„ÉÄ„É©„ÉºË®≠ÂÆöÊõ¥Êñ∞ ===
        // Á¨¨3ÂºïÊï∞false = CSSËá™ÂãïÊõ¥Êñ∞„ÇíÁÑ°ÂäπÂåñÔºàÊâãÂãïÂà∂Âæ°Ôºâ
        renderer.setSize(renderWidth, renderHeight, false);
        
        // „Éî„ÇØ„Çª„É´ÊØî„Çí1„Å´Âõ∫ÂÆö„Åó„Å¶„ÄÅËß£ÂÉèÂ∫¶„Çπ„Ç±„Éº„É´„ÅÆÂäπÊûú„ÇíÊòéÁ¢∫„Å´„Åô„Çã
        renderer.setPixelRatio(1);
        
        // === CSSË°®Á§∫„Çµ„Ç§„Ç∫„ÇíÂº∑Âà∂Ë®≠ÂÆö ===
        // Ëß£ÂÉèÂ∫¶„Çπ„Ç±„Éº„É´„Å´Èñ¢‰øÇ„Å™„ÅèÂ∏∏„Å´ÁîªÈù¢„ÅÑ„Å£„Å±„ÅÑ„Å´Ë°®Á§∫
        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';
        
        // ÁîªÂÉè„ÅÆ„Çπ„Ç±„Éº„É™„É≥„Ç∞ÂìÅË≥™„ÇíË®≠ÂÆö
        canvas.style.imageRendering = scale < 1 ? 'auto' : 'crisp-edges';
        
        // === „Éù„Çπ„Éà„Éó„É≠„Çª„ÉÉ„Ç∑„É≥„Ç∞ÂØæÂøú ===
        if (composer) {
            composer.setSize(renderWidth, renderHeight);
        }
        
        // === „Ç´„É°„É©Ë®≠ÂÆöÊõ¥Êñ∞ ===
        // „Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÅØË°®Á§∫„Çµ„Ç§„Ç∫Âü∫Ê∫ñÔºàÂÜÖÈÉ®Ëß£ÂÉèÂ∫¶„Åß„ÅØ„Å™„ÅÑÔºâ
        if (camera) {
            camera.aspect = displayWidth / displayHeight;
            camera.updateProjectionMatrix();
        }
        
        console.log(`[GraphicsEngine] After - Canvas internal size: ${canvas.width}x${canvas.height}`);
        console.log(`[GraphicsEngine] After - Canvas CSS size: ${canvas.style.width}x${canvas.style.height}`);
        console.log(`[GraphicsEngine] Expected visual quality: ${scale < 1 ? 'Blurry/Pixelated' : scale > 1 ? 'Sharp/Crisp' : 'Normal'}`);
        console.log(`[GraphicsEngine] =============================`);
        
        // „Éá„Éê„ÉÉ„Ç∞Áî®Ôºö„ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥„ÇíËøΩÂä†ÔºàÈñãÁô∫ÊôÇ„ÅÆ„ÅøÔºâ
        if ((window as any).DEBUG_RESOLUTION_SCALE) {
            // this.addResolutionTestPattern(scale); // TODO: Implement test pattern
        }
        
        // StarfieldÊõ¥Êñ∞„Çí‰∏ÄÊôÇÁöÑ„Å´„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„ÉàÔºà„Ç®„É©„ÉºÂõûÈÅøÔºâ
        // TODO: updateStarfieldsForResolution„É°„ÇΩ„ÉÉ„Éâ„ÅÆthis„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÂïèÈ°å„Çí‰øÆÊ≠£
        // this.updateStarfieldsForResolution(scale, pixelRatio);
    }
    
    // Anti-aliasing settings
    private applyAntiAliasing(type: string): void {
        console.log(`üîß Anti-aliasing setting: ${type}`);
        
        // „Ç¢„É≥„ÉÅ„Ç®„Ç§„É™„Ç¢„Ç∑„É≥„Ç∞„ÅÆË®≠ÂÆö„Çí‰øùÂ≠ò
        (renderer as any).__requestedAntialiasing = type;
        
        // FXAA„ÅÆÂ†¥Âêà„ÅØ„Éù„Çπ„Éà„Éó„É≠„Çª„ÉÉ„Ç∑„É≥„Ç∞„ÅßÂá¶ÁêÜ
        if (type === 'fxaa') {
            // FXAA„ÇíÊúâÂäπÂåñ
            this.applyFXAAAntialiasing(true);
            console.log('üîß FXAA applied via post-processing');
            
            // MSAA„ÇíÁÑ°ÂäπÂåñ„Åô„Çã„Åü„ÇÅ„Å´„Éî„ÇØ„Çª„É´ÊØî„ÇíÊ®ôÊ∫ñ„Å´
            renderer.setPixelRatio(window.devicePixelRatio || 1);
        } else {
            // FXAA„ÇíÁÑ°ÂäπÂåñ
            this.applyFXAAAntialiasing(false);
            
            if (type === 'off') {
                // „Ç¢„É≥„ÉÅ„Ç®„Ç§„É™„Ç¢„Ç∑„É≥„Ç∞„ÇíÁÑ°ÂäπÂåñ
                renderer.setPixelRatio(1);
            } else if (type.includes('msaa')) {
                // MSAA„ÅØ„É¨„É≥„ÉÄ„É©„ÉºÂÜç‰ΩúÊàê„ÅåÂøÖË¶Å
                console.log(`üîß ${type} requires renderer recreation. Will be applied on next reload.`);
                // ‰∏ÄÊôÇÁöÑ„Å´„Éî„ÇØ„Çª„É´ÊØî„ÇíË™øÊï¥„Åó„Å¶Êªë„Çâ„Åã„Åï„ÇíË£úÂÆå
                const pixelRatio = window.devicePixelRatio || 1;
                if (type === 'msaa8x') {
                    renderer.setPixelRatio(Math.min(pixelRatio * 1.5, 2));
                } else if (type === 'msaa4x') {
                    renderer.setPixelRatio(Math.min(pixelRatio * 1.25, 2));
                } else {
                    renderer.setPixelRatio(pixelRatio);
                }
            }
        }
        
        // Ë®≠ÂÆö„Çí„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò„Åó„Å¶Ê¨°ÂõûËµ∑ÂãïÊôÇ„Å´ÈÅ©Áî®
        if (typeof localStorage !== 'undefined') {
            localStorage.setItem('requestedAntialiasing', type);
        }
    }
    
    // Shadow quality settings
    private applyShadowQuality(quality: string): void {
        renderer.shadowMap.enabled = quality !== 'off';
        
        if (quality !== 'off') {
            switch (quality) {
                case 'ultra':
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    break;
                case 'high':
                    renderer.shadowMap.type = THREE.PCFShadowMap;
                    break;
                case 'medium':
                    renderer.shadowMap.type = THREE.BasicShadowMap;
                    break;
                case 'low':
                    renderer.shadowMap.type = THREE.BasicShadowMap;
                    break;
            }
            
            // Update shadow map size based on quality
            const shadowMapSize = this.getShadowMapSize(quality);
            scene.traverse((object) => {
                if (object instanceof THREE.Light && object.shadow) {
                    object.shadow.mapSize.width = shadowMapSize;
                    object.shadow.mapSize.height = shadowMapSize;
                    object.shadow.map = null; // Force recreation
                }
            });
        }
        
        console.log(`‚òÄÔ∏è Shadow quality set to: ${quality}`);
    }
    
    private getShadowMapSize(quality: string): number {
        switch (quality) {
            case 'ultra': return 4096;
            case 'high': return 2048;
            case 'medium': return 1024;
            case 'low': return 512;
            default: return 1024;
        }
    }
    
    // Post-processing effects
    private applyPostProcessing(quality: string): void {
        if (!composer) {
            console.warn('[GRAPHICS] Composer not available for post-processing');
            return;
        }
        
        // Bloom„Éë„Çπ„ÇíÁõ¥Êé•‰ΩøÁî®
        if (!bloomPass) {
            console.error('[GRAPHICS] BloomPass not available');
            return;
        }
        
        if (quality === 'off') {
            // „Éù„Çπ„Éà„Éó„É≠„Çª„ÉÉ„Ç∑„É≥„Ç∞„ÇíÂÆåÂÖ®„Å´ÁÑ°ÂäπÂåñ
            this.postProcessingEnabled = false;
            if (bloomPass) {
                bloomPass.enabled = false;
            }
        } else {
            // „Éù„Çπ„Éà„Éó„É≠„Çª„ÉÉ„Ç∑„É≥„Ç∞„ÇíÊúâÂäπÂåñ
            this.postProcessingEnabled = true;
            
            if (bloomPass) {
                bloomPass.enabled = true;
                
                // ÂìÅË≥™„Å´Âøú„Åò„Å¶Bloom„ÅÆÂº∑Â∫¶„ÇíË™øÊï¥
                switch (quality) {
                case 'ultra':
                    bloomPass.strength = 4.5;  // Ë∂ÖÂº∑Âäõ„Å™ÂÖâ
                    bloomPass.threshold = 0.0001;  // È´ò„Å®„Åª„ÅºÂêå„ÅòÔºà„Ç®„ÉÉ„Ç∏„ÇíÈò≤„ÅêÔºâ
                    bloomPass.radius = 0.9;  // È´ò„Çà„ÇäÂ∞ë„ÅóÂ§ß„Åç„ÅÑ
                    break;
                case 'high':
                    bloomPass.strength = 2.0;
                    bloomPass.threshold = 0.5;
                    bloomPass.radius = 0.8;
                    break;
                case 'medium':
                    bloomPass.strength = 1.5;
                    bloomPass.threshold = 0.6;
                    bloomPass.radius = 0.5;
                    break;
                case 'low':
                    bloomPass.strength = 1.0;  // Êéß„Åà„ÇÅ„Å™ÂäπÊûú
                    bloomPass.threshold = 0.7;  // ÈùûÂ∏∏„Å´Êòé„Çã„ÅÑÈÉ®ÂàÜ„ÅÆ„Åø
                    bloomPass.radius = 0.3;  // Â∞è„Åï„Å™„Ç∞„É≠„Éº
                    break;
            }
            
                // Bloom„Éë„Çπ„ÅÆËß£ÂÉèÂ∫¶„ÇÇË™øÊï¥
                const resolution = this.getPostProcessingResolution(quality);
                if (bloomPass.resolution) {
                    bloomPass.resolution.set(resolution.x, resolution.y);
                }
                
                // Bloom„Éë„Çπ„ÅÆÊõ¥Êñ∞„ÇíÂº∑Âà∂
                // UnrealBloomPass„ÅØÂÜÖÈÉ®„Åßuniforms„ÇíÁÆ°ÁêÜ„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ
                // Áõ¥Êé•„Ç¢„ÇØ„Çª„Çπ„Åô„ÇãÂøÖË¶Å„ÅØ„Å™„ÅÑ
                
                // „Éá„Éê„ÉÉ„Ç∞: ÂÆüÈöõ„ÅÆË®≠ÂÆöÂÄ§„ÇíÁ¢∫Ë™ç
                console.log(`‚ú® Bloom settings applied - strength: ${bloomPass.strength}, threshold: ${bloomPass.threshold}, radius: ${bloomPass.radius}, resolution: ${resolution.x}x${resolution.y}`);
            }
        }
        
        console.log(`‚ú® Post-processing set to: ${quality}, enabled: ${this.postProcessingEnabled}`);
    }
    
    // „Éù„Çπ„Éà„Éó„É≠„Çª„ÉÉ„Ç∑„É≥„Ç∞„ÅÆËß£ÂÉèÂ∫¶„ÇíÂèñÂæó
    private getPostProcessingResolution(quality: string): THREE.Vector2 {
        const baseWidth = window.innerWidth;
        const baseHeight = window.innerHeight;
        
        switch (quality) {
            case 'ultra':
                return new THREE.Vector2(baseWidth, baseHeight);  // „Éï„É´Ëß£ÂÉèÂ∫¶
            case 'high':
                return new THREE.Vector2(baseWidth * 0.8, baseHeight * 0.8);
            case 'medium':
                return new THREE.Vector2(baseWidth * 0.5, baseHeight * 0.5);
            case 'low':
                return new THREE.Vector2(baseWidth * 0.3, baseHeight * 0.3);  // ‰ΩéËß£ÂÉèÂ∫¶
            default:
                return new THREE.Vector2(baseWidth * 0.5, baseHeight * 0.5);
        }
    }
    
    // View distance (camera far plane)
    applyViewDistance(distance: string): void {
        let farPlane: number;
        
        switch (distance) {
            case 'unlimited':
                farPlane = 50000;
                break;
            case 'far':
                farPlane = 30000;
                break;
            case 'medium':
                farPlane = 20000;
                break;
            case 'near':
                farPlane = 15000;
                break;
            case 'minimal':
                farPlane = 10000;
                break;
            default:
                farPlane = 20000;
        }
        
        camera.far = farPlane;
        camera.updateProjectionMatrix();
        
        // Update fog far distance to match
        if (scene.fog && scene.fog instanceof THREE.Fog) {
            scene.fog.far = farPlane * 0.8;
        }
        
        console.log(`üëÅÔ∏è View distance set to: ${distance} (${farPlane})`);
    }
    
    // Lighting quality
    private applyLightingQuality(quality: string): void {
        // Adjust ambient light based on quality
        switch (quality) {
            case 'ultra':
                ambientLight.intensity = 0.3;
                break;
            case 'high':
                ambientLight.intensity = 0.4;
                break;
            case 'medium':
                ambientLight.intensity = 0.5;
                break;
            case 'low':
                ambientLight.intensity = 0.6;
                break;
        }
        
        // In a full implementation, you would also adjust the number and complexity of lights
        console.log(`üí° Lighting quality set to: ${quality}`);
    }
    
    // Fog effects
    private applyFogEffect(effect: string): void {
        switch (effect) {
            case 'off':
                scene.fog = null;
                break;
            case 'simple':
                scene.fog = new THREE.Fog(0x000011, 5000, 15000);
                break;
            case 'standard':
                scene.fog = new THREE.Fog(0x000011, 3000, camera.far * 0.8);
                break;
            case 'high':
                scene.fog = new THREE.FogExp2(0x000011, 0.00008);
                break;
        }
        
        console.log(`üå´Ô∏è Fog effect set to: ${effect}`);
    }
    
    // Render precision
    private applyRenderPrecision(precision: string): void {
        // Note: Three.js WebGLRenderer doesn't have a direct precision property
        // This would need to be set during renderer creation via constructor options
        // For now, we'll log the change and store it for future renderer recreation
        (renderer as any).__requestedPrecision = precision;
        
        console.log(`üéØ Render precision set to: ${precision}`);
    }
    
    // Particle density
    private applyParticleDensity(density: number): void {
        console.log(`‚ú® Particle density set to: ${Math.round(density * 100)}%`);
        
        // Find and update the starfield
        const starfield = scene.getObjectByName('starfield');
        console.log('‚ú® Scene children:', scene.children.map(c => c.name || c.type));
        console.log('‚ú® Starfield object:', starfield);
        
        if (starfield && starfield instanceof THREE.Points) {
            console.log('‚ú® Starfield found and is Points object');
            const geometry = starfield.geometry as THREE.BufferGeometry;
            const positionAttribute = geometry.getAttribute('position');
            
            console.log('‚ú® Starfield userData:', starfield.userData);
            console.log('‚ú® Position attribute:', positionAttribute);
            
            if (positionAttribute && starfield.userData.originalPositions) {
                // Use cached original positions
                const originalPositions = starfield.userData.originalPositions;
                const totalPoints = originalPositions.length / 3;
                const visiblePoints = Math.max(1, Math.floor(totalPoints * density)); // At least 1 star
                
                console.log(`‚ú® Original points: ${totalPoints}, Visible points: ${visiblePoints}`);
                
                // Create new position array with visible points
                const newPositions = new Float32Array(visiblePoints * 3);
                let hasValidData = false;
                for (let i = 0; i < visiblePoints * 3; i++) {
                    const value = originalPositions[i];
                    if (isFinite(value)) {
                        newPositions[i] = value;
                        hasValidData = true;
                    } else {
                        // „Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíË®≠ÂÆö
                        newPositions[i] = 0;
                        console.warn(`‚ú® NaN value found at index ${i}, using default 0`);
                    }
                }
                
                // Update geometry only if we have valid data
                if (hasValidData) {
                    geometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
                    geometry.attributes.position.needsUpdate = true;
                    
                    // Recompute bounding sphere only if data is valid
                    try {
                        geometry.computeBoundingSphere();
                    } catch (error) {
                        console.error('‚ú® Error computing bounding sphere:', error);
                    }
                } else {
                    console.error('‚ú® No valid position data found in starfield');
                }
                
                console.log(`‚ú® Starfield updated: ${visiblePoints}/${totalPoints} stars visible`);
            } else {
                console.warn('‚ú® Missing position attribute or originalPositions');
                console.warn('‚ú® positionAttribute:', !!positionAttribute);
                console.warn('‚ú® originalPositions:', !!starfield.userData.originalPositions);
            }
        } else {
            console.warn('‚ú® Starfield not found or not Points object');
            console.warn('‚ú® starfield:', starfield);
            console.warn('‚ú® instanceof Points:', starfield instanceof THREE.Points);
        }
    }
    
    // Texture quality settings
    private applyTextureQuality(quality: string): void {
        console.log(`üé® Texture quality set to: ${quality}`);
        
        // „ÉÜ„ÇØ„Çπ„ÉÅ„É£Ëß£ÂÉèÂ∫¶„ÅÆÂÄçÁéá„ÇíË®≠ÂÆö
        let textureScale = 1.0;
        switch (quality) {
            case 'ultra':
                textureScale = 2.0;
                break;
            case 'high':
                textureScale = 1.0;
                break;
            case 'medium':
                textureScale = 0.5;
                break;
            case 'low':
                textureScale = 0.25;
                break;
        }
        
        // Â§©‰Ωì„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÂìÅË≥™„ÇíÊõ¥Êñ∞
        scene.traverse((object) => {
            if (object instanceof THREE.Mesh && object.userData && object.userData.type) {
                const material = object.material as THREE.MeshStandardMaterial;
                if (material && material.map && material.map instanceof THREE.CanvasTexture) {
                    const texture = material.map;
                    const canvas = texture.image as HTMLCanvasElement;
                    if (canvas && canvas.width && canvas.height) {
                        // „Ç™„É™„Ç∏„Éä„É´„ÅÆ„Çµ„Ç§„Ç∫„Çí‰øùÂ≠ò
                        if (!object.userData.originalTextureSize) {
                            object.userData.originalTextureSize = {
                                width: canvas.width,
                                height: canvas.height
                            };
                        }
                        
                        // Êñ∞„Åó„ÅÑ„Çµ„Ç§„Ç∫„ÇíË®àÁÆó
                        const originalSize = object.userData.originalTextureSize;
                        const newWidth = Math.max(32, Math.round(originalSize.width * textureScale));
                        const newHeight = Math.max(32, Math.round(originalSize.height * textureScale));
                        
                        // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÅÆ„Çµ„Ç§„Ç∫„ÅåÂ§â„Çè„ÇãÂ†¥Âêà„ÅÆ„ÅøÊõ¥Êñ∞
                        if (canvas.width !== newWidth || canvas.height !== newHeight) {
                            console.log(`[TEXTURE] Updating ${object.userData.type} texture: ${canvas.width}x${canvas.height} -> ${newWidth}x${newHeight}`);
                            // Ê≥®ÊÑè: ÂÆüÈöõ„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„É™„Çµ„Ç§„Ç∫„ÅØÂà•ÈÄîÂÆüË£Ö„ÅåÂøÖË¶Å
                            // „Åì„Åì„Åß„ÅØ„Çµ„Ç§„Ç∫ÊÉÖÂ†±„ÅÆÊõ¥Êñ∞„ÅÆ„Åø
                            object.userData.currentTextureSize = {
                                width: newWidth,
                                height: newHeight
                            };
                        }
                    }
                }
            }
        });
        
        // ËÉåÊôØÈäÄÊ≤≥„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÂìÅË≥™„ÇÇË™øÊï¥ÔºàÂ∞ÜÊù•ÁöÑ„Å™ÂÆüË£ÖÁî®Ôºâ
        const backgroundGalaxy = scene.getObjectByName('backgroundGalaxies');
        if (backgroundGalaxy) {
            backgroundGalaxy.userData.textureQuality = quality;
        }
    }
    
    // Object detail (LOD) settings
    private applyObjectDetail(detail: string): void {
        console.log(`üî≤ Object detail set to: ${detail}`);
        
        // ÁêÉ‰Ωì„ÅÆ„Çª„Ç∞„É°„É≥„ÉàÊï∞„ÇíË®≠ÂÆö
        let segments = 32;
        switch (detail) {
            case 'ultra':
                segments = 64;
                break;
            case 'high':
                segments = 32;
                break;
            case 'medium':
                segments = 16;
                break;
            case 'low':
                segments = 8;
                break;
        }
        
        // Êó¢Â≠ò„ÅÆÂ§©‰Ωì„ÅÆË©≥Á¥∞Â∫¶„ÇíÊõ¥Êñ∞
        scene.traverse((object) => {
            if (object instanceof THREE.Mesh && object.userData && object.userData.type) {
                const celestialType = object.userData.type;
                
                // Â§©‰Ωì„ÅÆ„É°„ÉÉ„Ç∑„É•„ÇíË¶ã„Å§„Åë„ÇãÔºàÈÄöÂ∏∏„ÅØÊúÄÂàù„ÅÆÂ≠êË¶ÅÁ¥†Ôºâ
                let meshToUpdate: THREE.Mesh | null = null;
                if (object.children.length > 0 && object.children[0] instanceof THREE.Mesh) {
                    meshToUpdate = object.children[0] as THREE.Mesh;
                } else if (object.geometry) {
                    meshToUpdate = object;
                }
                
                if (meshToUpdate && meshToUpdate.geometry instanceof THREE.SphereGeometry) {
                    // ÁèæÂú®„ÅÆ„Çπ„Ç±„Éº„É´„Å®„Éû„ÉÜ„É™„Ç¢„É´„Çí‰øùÂ≠ò
                    const currentScale = meshToUpdate.scale.clone();
                    const currentMaterial = meshToUpdate.material;
                    
                    // Êñ∞„Åó„ÅÑ„Ç∏„Ç™„É°„Éà„É™„Çí‰ΩúÊàê
                    const radius = 1; // „Éá„Éï„Ç©„É´„ÉàÂçäÂæÑÔºà„Çπ„Ç±„Éº„É´„ÅßË™øÊï¥Ôºâ
                    const newGeometry = new THREE.SphereGeometry(radius, segments, segments);
                    
                    // „Ç∏„Ç™„É°„Éà„É™„ÇíÁΩÆ„ÅçÊèõ„Åà
                    meshToUpdate.geometry.dispose();
                    meshToUpdate.geometry = newGeometry;
                    
                    console.log(`[DETAIL] Updated ${celestialType} mesh with ${segments} segments`);
                }
            }
        });
        
        // LOD„Ç∑„Çπ„ÉÜ„É†„ÅÆË∑ùÈõ¢Ë™øÊï¥
        for (const [object, lodSystem] of this.lodSystems) {
            lodSystem.update(camera, detail);
        }
    }
    
    // Background detail settings
    private applyBackgroundDetail(detail: string): void {
        console.log(`üåå Background detail set to: ${detail}`);
        
        // ËÉåÊôØÈäÄÊ≤≥„Ç∞„É´„Éº„Éó„ÇíÊé¢„Åô
        const galaxyGroup = scene.getObjectByName('backgroundGalaxies');
        const nebulaGroup = scene.getObjectByName('nebulae');
        
        if (galaxyGroup) {
            switch (detail) {
                case 'off':
                    galaxyGroup.visible = false;
                    if (nebulaGroup) nebulaGroup.visible = false;
                    break;
                    
                case 'simple':
                    galaxyGroup.visible = true;
                    if (nebulaGroup) nebulaGroup.visible = false;
                    // Âü∫Êú¨ÁöÑ„Å™Êòü„ÅÆ„ÅøË°®Á§∫
                    galaxyGroup.traverse((child) => {
                        if (child instanceof THREE.Points) {
                            const name = child.name;
                            // „Éê„É´„Ç∏„Å®„Éè„É≠„Éº„ÅÆ„ÅøË°®Á§∫
                            child.visible = name === 'galacticBulge' || name === 'haloStars';
                            
                            // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´Êï∞„ÇíÂâäÊ∏õ
                            if (child.visible && child.geometry.attributes.position) {
                                const positions = child.geometry.attributes.position;
                                const originalCount = positions.count;
                                const reducedCount = Math.floor(originalCount * 0.5);
                                child.userData.visibleCount = reducedCount;
                                child.geometry.setDrawRange(0, reducedCount);
                            }
                        }
                    });
                    break;
                    
                case 'standard':
                    galaxyGroup.visible = true;
                    if (nebulaGroup) nebulaGroup.visible = true;
                    // Ê®ôÊ∫ñÁöÑ„Å™Ë°®Á§∫
                    galaxyGroup.traverse((child) => {
                        if (child instanceof THREE.Points) {
                            child.visible = true;
                            // ÈÄöÂ∏∏„ÅÆ„Éë„Éº„ÉÜ„Ç£„ÇØ„É´Êï∞
                            if (child.geometry.attributes.position) {
                                const positions = child.geometry.attributes.position;
                                const originalCount = positions.count;
                                const standardCount = Math.floor(originalCount * 0.75);
                                child.userData.visibleCount = standardCount;
                                child.geometry.setDrawRange(0, standardCount);
                            }
                        }
                    });
                    break;
                    
                case 'high':
                    galaxyGroup.visible = true;
                    if (nebulaGroup) nebulaGroup.visible = true;
                    // ÂÖ®„Å¶„ÅÆË©≥Á¥∞„ÇíË°®Á§∫
                    galaxyGroup.traverse((child) => {
                        if (child instanceof THREE.Points) {
                            child.visible = true;
                            // ÂÖ®„Å¶„ÅÆ„Éë„Éº„ÉÜ„Ç£„ÇØ„É´„ÇíË°®Á§∫
                            if (child.geometry.attributes.position) {
                                const positions = child.geometry.attributes.position;
                                child.geometry.setDrawRange(0, positions.count);
                                child.userData.visibleCount = positions.count;
                            }
                        }
                    });
                    break;
            }
            
            // ÊòüÈõ≤„ÅÆË©≥Á¥∞Â∫¶„ÇÇË™øÊï¥
            if (nebulaGroup) {
                nebulaGroup.traverse((child) => {
                    if (child instanceof THREE.Sprite || child instanceof THREE.Mesh) {
                        // Ë©≥Á¥∞Â∫¶„Å´Âøú„Åò„Å¶ÊòüÈõ≤„ÅÆË°®Á§∫„ÇíË™øÊï¥
                        if (detail === 'high') {
                            child.visible = true;
                            if ('material' in child && child.material) {
                                (child.material as THREE.SpriteMaterial).opacity = 0.6;
                            }
                        } else if (detail === 'standard') {
                            child.visible = Math.random() < 0.7; // 70%„ÅÆÊòüÈõ≤„ÇíË°®Á§∫
                            if ('material' in child && child.material) {
                                (child.material as THREE.SpriteMaterial).opacity = 0.4;
                            }
                        }
                    }
                });
            }
        }
    }
    
    // UI animations
    private applyUIAnimations(level: string): void {
        const rootElement = document.documentElement;
        
        // Add CSS class to control animation performance
        rootElement.classList.remove('ui-animations-off', 'ui-animations-simple', 'ui-animations-standard', 'ui-animations-smooth');
        
        switch (level) {
            case 'off':
                rootElement.classList.add('ui-animations-off');
                break;
            case 'simple':
                rootElement.classList.add('ui-animations-simple');
                break;
            case 'standard':
                rootElement.classList.add('ui-animations-standard');
                break;
            case 'smooth':
                rootElement.classList.add('ui-animations-smooth');
                break;
        }
        
        console.log(`üé≠ UI animations set to: ${level}`);
    }
    
    // Ë¢´ÂÜôÁïåÊ∑±Â∫¶ÔºàBokehÔºâÂäπÊûú„ÅÆÈÅ©Áî®
    applyBokehEffect(config: { enabled: boolean; focus?: number; aperture?: number; maxblur?: number }): void {
        if (!bokehPass) {
            console.warn('[GRAPHICS] BokehPass not available');
            return;
        }
        
        bokehPass.enabled = config.enabled;
        
        if (config.enabled) {
            // BokehPass„ÅÆuniforms„ÇíÂÆâÂÖ®„Å´Êõ¥Êñ∞
            try {
                if (bokehPass.uniforms) {
                    if (config.focus !== undefined && bokehPass.uniforms['focus']) {
                        bokehPass.uniforms['focus'].value = config.focus;
                    }
                    if (config.aperture !== undefined && bokehPass.uniforms['aperture']) {
                        bokehPass.uniforms['aperture'].value = config.aperture;
                    }
                    if (config.maxblur !== undefined && bokehPass.uniforms['maxblur']) {
                        bokehPass.uniforms['maxblur'].value = config.maxblur;
                    }
                } else {
                    console.warn('[GRAPHICS] BokehPass uniforms not available');
                }
            } catch (error) {
                console.error('[GRAPHICS] Error updating BokehPass uniforms:', error);
            }
            
            console.log(`üì∑ Bokeh effect enabled - focus: ${config.focus}, aperture: ${config.aperture}, maxblur: ${config.maxblur}`);
        } else {
            console.log('üì∑ Bokeh effect disabled');
        }
    }
    
    // „Éï„Ç£„É´„É†„Ç∞„É¨„Ç§„É≥ÂäπÊûú„ÅÆÈÅ©Áî®
    applyFilmGrainEffect(config: { enabled: boolean; noiseIntensity?: number; scanlinesIntensity?: number }): void {
        if (!filmPass) {
            console.warn('[GRAPHICS] FilmPass not available');
            return;
        }
        
        filmPass.enabled = config.enabled;
        
        if (config.enabled) {
            // FilmPass„ÅØ‰ΩúÊàêÊôÇ„ÅÆ„Éë„É©„É°„Éº„Çø„ÅßË®≠ÂÆö„Åï„Çå„ÄÅÂæå„Åã„ÇâÂ§âÊõ¥„Åß„Åç„Å™„ÅÑ
            // Â∞ÜÊù•ÁöÑ„Å´„ÅØÊñ∞„Åó„ÅÑFilmPass„Çí‰ΩúÊàê„Åó„Å¶ÁΩÆ„ÅçÊèõ„Åà„ÇãÂÆüË£Ö„ÅåÂøÖË¶Å
            console.log(`üéûÔ∏è Film grain effect enabled - noise: ${config.noiseIntensity}, scanlines: ${config.scanlinesIntensity}`);
            console.log('[GRAPHICS] Note: FilmPass intensity changes require pass recreation (not implemented yet)');
        } else {
            console.log('üéûÔ∏è Film grain effect disabled');
        }
    }
    
    // Ëâ≤Ë£úÊ≠£„ÅÆÈÅ©Áî®
    applyColorCorrection(config: { enabled: boolean; brightness?: number; contrast?: number; saturation?: number }): void {
        if (!colorCorrectionPass) {
            console.warn('[GRAPHICS] ColorCorrectionPass not available');
            return;
        }
        
        colorCorrectionPass.enabled = config.enabled;
        
        if (config.enabled) {
            try {
                if (colorCorrectionPass.uniforms) {
                    // brightness: RGB power values (2.2 = standard gamma)
                    if (config.brightness !== undefined && colorCorrectionPass.uniforms['powRGB']) {
                        const power = 2.2 / config.brightness;
                        if (colorCorrectionPass.uniforms['powRGB'].value) {
                            colorCorrectionPass.uniforms['powRGB'].value.set(power, power, power);
                        }
                    }
                    
                    // contrast & saturation: RGB multipliers
                    if ((config.contrast !== undefined || config.saturation !== undefined) && colorCorrectionPass.uniforms['mulRGB']) {
                        const contrast = config.contrast !== undefined ? config.contrast : 1.0;
                        const saturation = config.saturation !== undefined ? config.saturation : 1.0;
                        
                        // Apply contrast and saturation
                        const r = contrast * saturation;
                        const g = contrast * saturation;
                        const b = contrast * saturation;
                        if (colorCorrectionPass.uniforms['mulRGB'].value) {
                            colorCorrectionPass.uniforms['mulRGB'].value.set(r, g, b);
                        }
                    }
                } else {
                    console.warn('[GRAPHICS] ColorCorrectionPass uniforms not available');
                }
            } catch (error) {
                console.error('[GRAPHICS] Error updating ColorCorrectionPass uniforms:', error);
            }
            
            console.log(`üé® Color correction enabled - brightness: ${config.brightness}, contrast: ${config.contrast}, saturation: ${config.saturation}`);
        } else {
            console.log('üé® Color correction disabled');
        }
    }
    
    // „Éì„Éç„ÉÉ„ÉàÂäπÊûú„ÅÆÈÅ©Áî®
    applyVignetteEffect(config: { enabled: boolean; offset?: number; darkness?: number }): void {
        if (!vignettePass) {
            console.warn('[GRAPHICS] VignettePass not available');
            return;
        }
        
        vignettePass.enabled = config.enabled;
        
        if (config.enabled) {
            try {
                if (vignettePass.uniforms) {
                    if (config.offset !== undefined && vignettePass.uniforms['offset']) {
                        vignettePass.uniforms['offset'].value = config.offset;
                    }
                    if (config.darkness !== undefined && vignettePass.uniforms['darkness']) {
                        vignettePass.uniforms['darkness'].value = config.darkness;
                    }
                } else {
                    console.warn('[GRAPHICS] VignettePass uniforms not available');
                }
            } catch (error) {
                console.error('[GRAPHICS] Error updating VignettePass uniforms:', error);
            }
            
            console.log(`üñºÔ∏è Vignette effect enabled - offset: ${config.offset}, darkness: ${config.darkness}`);
        } else {
            console.log('üñºÔ∏è Vignette effect disabled');
        }
    }
    
    // FXAA„Ç¢„É≥„ÉÅ„Ç®„Ç§„É™„Ç¢„Ç∑„É≥„Ç∞„ÅÆÈÅ©Áî®
    applyFXAAAntialiasing(enabled: boolean): void {
        if (!fxaaPass) {
            console.warn('[GRAPHICS] FXAAPass not available');
            return;
        }
        
        fxaaPass.enabled = enabled;
        
        // Ëß£ÂÉèÂ∫¶„ÅÆÊõ¥Êñ∞
        if (enabled) {
            try {
                if (fxaaPass.uniforms && fxaaPass.uniforms['resolution'] && fxaaPass.uniforms['resolution'].value) {
                    fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                } else {
                    console.warn('[GRAPHICS] FXAAPass resolution uniform not available');
                }
            } catch (error) {
                console.error('[GRAPHICS] Error updating FXAAPass uniforms:', error);
            }
        }
        
        console.log(`üîß FXAA antialiasing ${enabled ? 'enabled' : 'disabled'}`);
    }
    
    // „Éà„Éº„É≥„Éû„ÉÉ„Éî„É≥„Ç∞„ÅÆÈÅ©Áî®
    applyToneMapping(type: string): void {
        // Handle different naming conventions
        const mode = type.toLowerCase();
        
        switch (mode) {
            case 'none':
            case 'off':
                renderer.toneMapping = THREE.NoToneMapping;
                break;
            case 'linear':
                renderer.toneMapping = THREE.LinearToneMapping;
                break;
            case 'reinhard':
                renderer.toneMapping = THREE.ReinhardToneMapping;
                break;
            case 'cineon':
            case 'filmic':
                renderer.toneMapping = THREE.CineonToneMapping;
                break;
            case 'aces':
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                break;
            default:
                renderer.toneMapping = THREE.NoToneMapping;
        }
        
        renderer.toneMappingExposure = mode === 'aces' ? 1.0 : 1.5;
        
        console.log(`üé¨ Tone mapping set to: ${type}`);
    }
    
    // „Éì„Ç∏„É•„Ç¢„É´„Çπ„Çø„Ç§„É´„Ç®„Éï„Çß„ÇØ„Éà„ÅÆÈÅ©Áî®
    applyVisualStyleEffects(graphics: GraphicsState): void {
        // „Éñ„É´„Éº„É†ÂäπÊûú
        if (graphics.bloom !== undefined) {
            this.applyPostProcessing(graphics.bloom);
        }
        
        // Ë¢´ÂÜôÁïåÊ∑±Â∫¶
        if (graphics.depthOfField !== undefined) {
            this.applyBokehEffect({
                enabled: graphics.depthOfField !== 'off',
                focus: graphics.depthOfField === 'dynamic' ? 1000 : 2000,
                aperture: graphics.depthOfField === 'dynamic' ? 0.025 : 0.05,
                maxblur: graphics.depthOfField === 'dynamic' ? 0.01 : 0.02
            });
        }
        
        // „Éï„Ç£„É´„É†„Ç∞„É¨„Ç§„É≥
        if (graphics.filmGrain !== undefined) {
            this.applyFilmGrainEffect({
                enabled: graphics.filmGrain,
                noiseIntensity: (graphics.filmGrainIntensity || 50) / 100 * 0.5,
                scanlinesIntensity: (graphics.filmGrainIntensity || 50) / 100 * 0.05
            });
        }
        
        // „Éà„Éº„É≥„Éû„ÉÉ„Éî„É≥„Ç∞
        if (graphics.toneMapping !== undefined) {
            this.applyToneMapping(graphics.toneMapping);
        }
        
        // Ëâ≤Ë£úÊ≠£
        if (graphics.colorCorrection !== undefined) {
            this.applyColorCorrection({
                enabled: graphics.colorCorrection,
                brightness: (graphics.brightness || 100) / 100,
                contrast: (graphics.contrast || 100) / 100,
                saturation: (graphics.saturation || 100) / 100
            });
        }
        
        // „Éì„Éç„ÉÉ„ÉàÂäπÊûú
        if (graphics.vignette !== undefined) {
            this.applyVignetteEffect({
                enabled: graphics.vignette,
                offset: 1.0,
                darkness: 1.0 + ((graphics.vignetteIntensity || 50) / 100 * 2.0)
            });
        }
        
        console.log(`üé® Visual style effects applied for: ${graphics.visualStyle}`);
    }
    
    // LOD (Level of Detail) management
    private updateLODSystems(): void {
        const objectDetail = gameStateManager.getState().graphics.objectDetail;
        
        // Update existing LOD systems
        for (const [object, lodSystem] of this.lodSystems) {
            lodSystem.update(camera, objectDetail);
        }
    }
    
    // Add LOD system to an object
    addLODSystem(object: THREE.Object3D, highDetail: THREE.Object3D, mediumDetail: THREE.Object3D, lowDetail: THREE.Object3D): void {
        const lodSystem = new LODSystem(object, highDetail, mediumDetail, lowDetail);
        this.lodSystems.set(object, lodSystem);
    }
    
    // Dynamic quality adjustment
    enableDynamicQuality(enabled: boolean): void {
        this.dynamicQualityEnabled = enabled;
        console.log(`üîÑ Dynamic quality adjustment: ${enabled ? 'enabled' : 'disabled'}`);
    }
    
    private handleDynamicQuality(): void {
        if (this.qualityAdjustmentCooldown > 0) {
            this.qualityAdjustmentCooldown--;
            return;
        }
        
        const targetFPS = 30;
        const currentFPS = performanceMonitor.getCurrentFPS();
        
        if (currentFPS < targetFPS * 0.8) {
            // Performance is poor, reduce quality
            this.reduceQuality();
            this.qualityAdjustmentCooldown = 300; // 5 seconds at 60fps
        } else if (currentFPS > targetFPS * 1.2) {
            // Performance is good, can increase quality
            this.increaseQuality();
            this.qualityAdjustmentCooldown = 300;
        }
    }
    
    private reduceQuality(): void {
        const graphics = gameStateManager.getState().graphics;
        let changed = false;
        
        // Reduce settings in order of performance impact
        if (graphics.resolutionScale > 0.5) {
            graphics.resolutionScale = Math.max(0.5, graphics.resolutionScale - 0.25);
            changed = true;
        } else if (graphics.shadowQuality !== 'off') {
            graphics.shadowQuality = 'off';
            changed = true;
        } else if (graphics.particleDensity > 0.1) {
            graphics.particleDensity = Math.max(0.1, graphics.particleDensity - 0.25);
            changed = true;
        }
        
        if (changed) {
            graphics.preset = 'custom';
            console.log('üìâ Dynamic quality reduction applied');
        }
    }
    
    private increaseQuality(): void {
        // Implementation for increasing quality when performance allows
        // This would be the reverse of reduceQuality
        console.log('üìà Dynamic quality could be increased');
    }
    
    // Get frame rate limiter
    getFrameRateLimiter(): FrameRateLimiter {
        return this.frameRateLimiter;
    }
    
    // Check if post-processing is enabled
    isPostProcessingEnabled(): boolean {
        return this.postProcessingEnabled;
    }
    
    // Initialize mobile optimizations
    private initializeMobileOptimizations(): void {
        if (isMobileDevice()) {
            console.log('üì± Mobile device detected - applying optimized settings');
            
            // „É¢„Éê„Ç§„É´Áî®„ÅÆ„Éá„Éï„Ç©„É´„ÉàË®≠ÂÆö„ÇíÈÅ©Áî®
            setTimeout(() => {
                const currentState = gameStateManager.getState();
                const isMobileOptimized = currentState.graphics.preset === 'mobile' || 
                                         currentState.graphics.preset === 'performance';
                
                if (!isMobileOptimized) {
                    console.log('üì± Applying mobile optimized graphics preset');
                    this.applyPreset('mobile');
                }
            }, 100); // ÂàùÊúüÂåñÂÆå‰∫ÜÂæå„Å´ÈÅ©Áî®
        }
    }
    
    // Apply mobile-specific optimizations
    applyMobileOptimizations(): void {
        if (!isMobileDevice()) return;
        
        console.log('üì± Applying mobile-specific optimizations');
        const graphics = gameStateManager.getState().graphics;
        
        // „É¢„Éê„Ç§„É´Áî®„ÅÆÊé®Â•®Ë®≠ÂÆö
        const mobileSettings: Partial<GraphicsState> = {
            resolutionScale: Math.min(graphics.resolutionScale, 0.75),
            antiAliasing: 'off',
            shadowQuality: 'low',
            postProcessing: 'low',
            viewDistance: 'medium',
            lightingQuality: 'medium',
            fogEffect: 'simple',
            textureQuality: 'medium',
            objectDetail: 'medium',
            backgroundDetail: 'simple',
            particleDensity: Math.min(graphics.particleDensity, 0.5),
            uiAnimations: 'simple',
            frameRateLimit: 30
        };
        
        // ÁèæÂú®„ÅÆË®≠ÂÆö„Å®ÊØîËºÉ„Åó„Å¶„ÄÅ„Çà„Çä‰Ωé„ÅÑË®≠ÂÆö„ÅÆ„ÅøÈÅ©Áî®
        const updatedSettings = { ...graphics };
        let hasChanges = false;
        
        // Ëß£ÂÉèÂ∫¶„Çπ„Ç±„Éº„É´
        if (mobileSettings.resolutionScale! < graphics.resolutionScale) {
            updatedSettings.resolutionScale = mobileSettings.resolutionScale!;
            hasChanges = true;
        }
        
        // ÂìÅË≥™Ë®≠ÂÆö„ÅÆÊØîËºÉ„Å®ÈÅ©Áî®
        const qualityLevels = ['off', 'low', 'medium', 'high', 'ultra'];
        const compareQuality = (current: string, recommended: string): string => {
            const currentIndex = qualityLevels.indexOf(current);
            const recommendedIndex = qualityLevels.indexOf(recommended);
            return currentIndex > recommendedIndex ? recommended : current;
        };
        
        // ÂêÑË®≠ÂÆö„ÅÆÈÅ©Áî®
        Object.keys(mobileSettings).forEach(key => {
            if (key === 'resolutionScale' || key === 'particleDensity' || key === 'frameRateLimit') {
                return; // Êó¢„Å´Âá¶ÁêÜÊ∏à„Åø„Åæ„Åü„ÅØÊï∞ÂÄ§Âûã
            }
            
            const currentValue = graphics[key as keyof GraphicsState];
            const recommendedValue = mobileSettings[key as keyof GraphicsState];
            
            if (typeof currentValue === 'string' && typeof recommendedValue === 'string') {
                const newValue = compareQuality(currentValue, recommendedValue);
                if (newValue !== currentValue) {
                    (updatedSettings as any)[key] = newValue;
                    hasChanges = true;
                }
            }
        });
        
        // „Éï„É¨„Éº„É†„É¨„Éº„ÉàÂà∂Èôê
        if (graphics.frameRateLimit > mobileSettings.frameRateLimit!) {
            updatedSettings.frameRateLimit = mobileSettings.frameRateLimit!;
            hasChanges = true;
        }
        
        if (hasChanges) {
            updatedSettings.preset = 'custom';
            gameStateManager.updateState(state => ({
                ...state,
                graphics: updatedSettings
            }));
            
            console.log('üì± Mobile optimizations applied:', updatedSettings);
        }
    }
    
    // Set canvas size (for resolution dropdown)
    setCanvasSize(width: number, height: number): void {
        console.log(`[GraphicsEngine] Setting canvas size to ${width}x${height}`);
        const state = gameStateManager.getState();
        
        // Update renderer size
        renderer.setSize(width, height);
        
        // Update camera aspect ratio
        if (camera) {
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        
        // Update composer if present
        if (composer) {
            composer.setSize(width, height);
        }
    }
    
    // Set FPS limit
    setFPSLimit(fps: number): void {
        console.log(`[GraphicsEngine] Setting FPS limit to ${fps}`);
        const state = gameStateManager.getState();
        state.graphics.frameRateLimit = fps;
        this.frameRateLimiter.setTargetFPS(fps);
    }
    
    // Set resolution scale
    setResolutionScale(scale: number): void {
        console.log(`[GraphicsEngine] Setting resolution scale to ${scale}`);
        const state = gameStateManager.getState();
        state.graphics.resolutionScale = scale;
        this.previousSettings.resolutionScale = scale; // Prevent re-application
        this.applyResolutionScale(scale);
    }
    
    // Secondary renderer support for dual view
    setSecondaryRenderer(secondaryRenderer: THREE.WebGLRenderer | null): void {
        console.log('[GraphicsEngine] Setting secondary renderer');
        this.secondaryRenderer = secondaryRenderer;
        
        if (secondaryRenderer) {
            // Create secondary camera
            this.secondaryCamera = new THREE.PerspectiveCamera(
                60, // FOV
                secondaryRenderer.domElement.width / secondaryRenderer.domElement.height,
                0.1,
                50000
            );
            
            // Position camera for overview
            this.secondaryCamera.position.set(0, 2000, 3000);
            this.secondaryCamera.lookAt(0, 0, 0);
        } else {
            this.secondaryCamera = null;
        }
    }
    
    // Render to secondary view
    renderSecondary(): void {
        if (!this.secondaryRenderer || !this.secondaryCamera) return;
        
        // Update secondary camera to follow main camera's target
        if (camera.userData.target) {
            const target = camera.userData.target as THREE.Vector3;
            this.secondaryCamera.lookAt(target);
            
            // Position secondary camera for a good overview
            const distance = 3000;
            const angle = Date.now() * 0.0001; // Slow rotation
            this.secondaryCamera.position.x = Math.sin(angle) * distance;
            this.secondaryCamera.position.z = Math.cos(angle) * distance;
            this.secondaryCamera.position.y = 2000;
        }
        
        // Render scene with secondary camera
        this.secondaryRenderer.render(scene, this.secondaryCamera);
    }
    
    // Handle window resize for both renderers
    handleResize(): void {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Update main renderer
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        
        if (composer) {
            composer.setSize(width, height);
        }
        
        // Update secondary renderer if present
        if (this.secondaryRenderer && this.secondaryCanvas) {
            const rect = this.secondaryCanvas.getBoundingClientRect();
            this.secondaryRenderer.setSize(rect.width, rect.height);
            
            if (this.secondaryCamera) {
                this.secondaryCamera.aspect = rect.width / rect.height;
                this.secondaryCamera.updateProjectionMatrix();
            }
        }
    }
    
    private secondaryCanvas: HTMLCanvasElement | null = null;
}

// Frame rate limiting utility
class FrameRateLimiter {
    private targetFPS: number = -1; // -1 means unlimited
    private lastFrameTime: number = 0;
    private frameInterval: number = 0;
    
    setTargetFPS(fps: number): void {
        this.targetFPS = fps;
        this.frameInterval = fps > 0 ? 1000 / fps : 0;
        console.log(`üéÆ Frame rate limiter: Target ${fps} FPS, interval ${this.frameInterval.toFixed(1)}ms`);
    }
    
    shouldRender(): boolean {
        if (this.targetFPS <= 0) return true; // Unlimited
        
        const now = performance.now();
        
        // ÂàùÂõû„Éï„É¨„Éº„É†„ÅÆÂá¶ÁêÜ
        if (this.lastFrameTime === 0) {
            this.lastFrameTime = now;
            return true;
        }
        
        const timeSinceLastFrame = now - this.lastFrameTime;
        
        if (timeSinceLastFrame >= this.frameInterval) {
            // Ê¨°„ÅÆ„Éï„É¨„Éº„É†„Çø„Ç§„Éü„É≥„Ç∞„ÇíË®àÁÆóÔºà„Çà„ÇäÊ≠£Á¢∫„Å™FPSÂà∂ÈôêÔºâ
            this.lastFrameTime = now - (timeSinceLastFrame % this.frameInterval);
            return true;
        }
        
        return false;
    }
}

// LOD (Level of Detail) system
class LODSystem {
    private levels: { distance: number; object: THREE.Object3D }[] = [];
    private currentLevel: number = -1;
    
    constructor(
        private parentObject: THREE.Object3D,
        highDetail: THREE.Object3D,
        mediumDetail: THREE.Object3D,
        lowDetail: THREE.Object3D
    ) {
        this.levels = [
            { distance: 0, object: highDetail },
            { distance: 500, object: mediumDetail },
            { distance: 2000, object: lowDetail }
        ];
        
        // Initially show high detail
        this.setLevel(0);
    }
    
    update(camera: THREE.Camera, qualitySetting: string): void {
        const distance = this.parentObject.position.distanceTo(camera.position);
        
        // Adjust distances based on quality setting
        const multiplier = this.getDistanceMultiplier(qualitySetting);
        
        let targetLevel = this.levels.length - 1;
        for (let i = 0; i < this.levels.length; i++) {
            if (distance < this.levels[i].distance * multiplier) {
                targetLevel = i;
                break;
            }
        }
        
        if (targetLevel !== this.currentLevel) {
            this.setLevel(targetLevel);
        }
    }
    
    private setLevel(level: number): void {
        // Hide current level
        if (this.currentLevel >= 0) {
            this.levels[this.currentLevel].object.visible = false;
        }
        
        // Show new level
        this.currentLevel = level;
        this.levels[level].object.visible = true;
    }
    
    private getDistanceMultiplier(quality: string): number {
        switch (quality) {
            case 'ultra': return 2.0;
            case 'high': return 1.5;
            case 'medium': return 1.0;
            case 'low': return 0.7;
            default: return 1.0;
        }
    }
    
    // Force resolution update (used by resize workaround)
    forceResolutionUpdate(): void {
        console.log('üîß Force resolution update called');
        if ((window as any).graphicsEngine) {
            (window as any).graphicsEngine.applyResolutionScale(gameStateManager.getState().graphics.resolutionScale);
        }
    }
    
    // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆöÔºàËß£ÂÉèÂ∫¶Ë®≠ÂÆöÁî®Ôºâ
    setCanvasSize(width: number, height: number): void {
        console.log(`[GraphicsEngine] Setting canvas size: ${width}x${height}`);
        
        // „É¨„É≥„ÉÄ„É©„Éº„ÅÆ„Çµ„Ç§„Ç∫„ÇíÊõ¥Êñ∞
        renderer.setSize(width, height);
        
        // „Ç´„É°„É©„ÅÆ„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÇíÊõ¥Êñ∞
        if (camera instanceof THREE.PerspectiveCamera) {
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        
        // „Ç≥„É≥„Éù„Éº„Ç∂„Éº„ÅÆ„Çµ„Ç§„Ç∫„ÇÇÊõ¥Êñ∞
        if (composer) {
            composer.setSize(width, height);
        }
    }
    
    // „É¨„É≥„ÉÄ„É™„É≥„Ç∞Ëß£ÂÉèÂ∫¶„Çπ„Ç±„Éº„É´„ÇíË®≠ÂÆö
    setResolutionScale(scale: number): void {
        console.log(`[GraphicsEngine] Setting resolution scale: ${scale}`);
        console.log(`[GraphicsEngine] Current window size: ${window.innerWidth}x${window.innerHeight}`);
        
        // ÁèæÂú®„ÅÆ„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„ÇπË®≠ÂÆö„ÇíÊõ¥Êñ∞
        const state = gameStateManager.getState();
        state.graphics.resolutionScale = scale;
        
        // previousSettings„ÇÇÊõ¥Êñ∞„Åó„Å¶„ÄÅupdate()„Åß„ÅÆÂÜçÈÅ©Áî®„ÇíÈò≤„Åê
        this.previousSettings.resolutionScale = scale;
        
        // Ëß£ÂÉèÂ∫¶„Çπ„Ç±„Éº„É´„ÇíÈÅ©Áî®
        this.applyResolutionScale(scale);
        
        // ÈÅ©Áî®Âæå„ÅÆ„Çµ„Ç§„Ç∫„ÇíÁ¢∫Ë™ç
        const canvas = renderer.domElement;
        console.log(`[GraphicsEngine] Canvas actual size: ${canvas.width}x${canvas.height}`);
        console.log(`[GraphicsEngine] Canvas CSS size: ${canvas.style.width}x${canvas.style.height}`);
    }
    
    // FPSÂà∂Èôê„ÇíË®≠ÂÆö
    setFPSLimit(fps: number): void {
        console.log(`[GraphicsEngine] Setting FPS limit: ${fps === 0 ? 'unlimited' : fps}`);
        
        // ÁèæÂú®„ÅÆ„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„ÇπË®≠ÂÆö„ÇíÊõ¥Êñ∞
        const state = gameStateManager.getState();
        state.graphics.frameRateLimit = fps;
        
        // „Éï„É¨„Éº„É†„É¨„Éº„Éà„É™„Éü„ÉÉ„Çø„Éº„ÇíÊõ¥Êñ∞
        this.frameRateLimiter.setTargetFPS(fps);
    }
    
    // Get camera for dual view system
    getCamera(): THREE.PerspectiveCamera | null {
        return camera;
    }
    
    // Get scene for dual view system
    getScene(): THREE.Scene | null {
        return scene;
    }
    
    // Handle resize event
    handleResize(): void {
        const container = renderer.domElement.parentElement;
        if (!container) return;
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Apply current resolution scale
        const scale = gameStateManager.getState().graphics.resolutionScale;
        const effectiveWidth = width * scale;
        const effectiveHeight = height * scale;
        
        // Update renderer size
        renderer.setSize(effectiveWidth, effectiveHeight);
        renderer.domElement.style.width = `${width}px`;
        renderer.domElement.style.height = `${height}px`;
        
        // Update camera aspect ratio
        if (camera instanceof THREE.PerspectiveCamera) {
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        
        // Update composer size
        if (composer) {
            composer.setSize(effectiveWidth, effectiveHeight);
        }
        
        console.log(`[GraphicsEngine] Resized to ${width}x${height} (effective: ${effectiveWidth}x${effectiveHeight})`);
    }
    
    // Reset camera for initialization (used during startup)
    resetCameraForInitialization(): void {
        console.log('üìπ Camera reset for initialization called');
        // This is a placeholder - actual camera reset logic would go here
        // For now, we'll just ensure resolution is applied
        if ((window as any).graphicsEngine) {
            (window as any).graphicsEngine.applyResolutionScale(gameStateManager.getState().graphics.resolutionScale);
        }
    }

    private updateStarfieldsForResolution(resolutionScale: number, devicePixelRatio: number): void {
        console.log(`[GraphicsEngine] Updating starfields for resolution scale: ${resolutionScale}`);
        
        // Update main starfield
        const mainStarfield = scene.getObjectByName('starfield');
        if (mainStarfield && mainStarfield instanceof THREE.Points) {
            const material = mainStarfield.material as THREE.PointsMaterial;
            const baseSize = mainStarfield.userData.baseStarSize || 0.8;
            
            starfieldOptimizer.updateStarfieldMaterial(material, {
                resolutionScale,
                devicePixelRatio,
                baseStarSize: baseSize,
                starCount: 8000
            });
        }
        
        // Update background galaxy starfields
        scene.traverse((child) => {
            if (child instanceof THREE.Points && child.userData.isBackgroundStarfield) {
                const material = child.material as THREE.PointsMaterial;
                const baseSize = child.userData.baseSize || 0.5;
                const layerDistance = child.userData.layerDistance || 5000;
                
                starfieldOptimizer.updateStarfieldMaterial(material, {
                    resolutionScale,
                    devicePixelRatio,
                    baseStarSize: baseSize,
                    starCount: 5000
                });
                
                starfieldOptimizer.optimizeBackgroundGalaxyMaterial(
                    material,
                    layerDistance,
                    resolutionScale
                );
            }
        });
    }
}

// Create global instance
export const graphicsEngine = new GraphicsEngine();