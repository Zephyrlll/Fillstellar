# サーバーサイド権威アーキテクチャガイド

## 1. 基本原則

**サーバーが唯一の信頼できる情報源（Single Source of Truth）である。**

プレイヤーのクライアント（ブラウザ）は、あくまでユーザーからの入力を受け付け、サーバーから送られてきた状態を表示するための「ビュー」に過ぎません。全てのゲームロジックの計算、状態の変更、データの検証は、必ずサーバーサイド（Rustバックエンド）で実行する必要があります。

## 2. なぜ重要か？

- **チート行為の防止:** クライアント側で計算を行うと、メモリ改ざんや不正なリクエストによって、資源を無限に増やしたり、実績を不正に解除したりすることが容易になります。
- **公平性の担保:** 将来マルチプレイヤー機能（特にランキング）を導入した際に、全プレイヤーが同じルールでプレイしていることを保証します。
- **ゲーム経済の保護:** 不正な手段で得たリソースがゲーム内に溢れることを防ぎます。

## 3. 実装ガイドライン

### やるべきこと (Do)

- **アクションを送信、状態を受信:**
  1. **クライアント:** 「このアップグレードを購入したい」という**アクション**をサーバーに送信します。
  2. **サーバー:** リクエストを受け取り、プレイヤーが必要な資源を持っているか、購入条件を満たしているかなど、全ての**検証**を行います。
  3. **サーバー:** 検証が通れば、データベース内のプレイヤーデータを**更新**します。
  4. **サーバー:** 更新後の**新しい状態**（例: 新しい資源量、購入済みアップグレードのリスト）をクライアントに送信します。
  5. **クライアント:** サーバーから受け取った新しい状態で画面を**再描画**します。

- **全ての計算をサーバーで行う:**
  - オフライン中の資源増加量
  - プレステージポイントの獲得量
  - 実績の達成判定
  - 研究の完了時間

### やってはいけないこと (Don't)

- **クライアントからの結果を信用しない:**
  - `{"action": "add_resource", "amount": 1000000}` のようなリクエストを許可してはいけません。
  - 「12時間オフラインだったので、これだけ資源が増えました」というクライアントからの申告を信用してはいけません。必ずサーバー側で最終ログイン時刻を元に計算してください。

## 4. 具体例：アップグレード購入フロー

1.  **Client (TypeScript):**
    ```typescript
    // ユーザーが購入ボタンをクリック
    const upgradeId = "celestial_body_lv2";
    api.post('/player/upgrades/buy', { upgradeId: upgradeId });
    ```

2.  **Server (Rust/Actix Web):**
    ```rust
    // POST /player/upgrades/buy のハンドラ
    async fn buy_upgrade(req: web::Json<BuyUpgradeRequest>, user: User) -> impl Responder {
        // 1. データベースから現在のプレイヤー状態を取得
        let mut player_state = db::get_player_state(user.id).await;

        // 2. アップグレードのコストや条件を取得
        let upgrade_cost = get_upgrade_cost(req.upgradeId);

        // 3. 検証：資源が足りるか？
        if player_state.resources < upgrade_cost {
            return HttpResponse::BadRequest().json("Not enough resources");
        }

        // 4. 状態の更新と保存
        player_state.resources -= upgrade_cost;
        player_state.unlocked_upgrades.push(req.upgradeId);
        db::save_player_state(player_state).await;

        // 5. 更新後の新しい状態をクライアントに返す
        HttpResponse::Ok().json(player_state)
    }
    ```
