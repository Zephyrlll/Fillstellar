# マルチプレイを考慮したデータモデル設計

## 1. 基本原則

**今日のシングルプレイのデータは、明日のマルチプレイのデータである。**

「とりあえずシングルプレイ用に」と一時的なデータ構造を作ることは避けてください。最初から、全てのデータが特定のプレイヤーに紐づき、複数のプレイヤーデータが共存できるような設計を徹底します。

## 2. 設計ガイドライン

### プレイヤー中心の設計

全てのデータは `player_id` を外部キーとして関連付けられるべきです。

- `players`: プレイヤーアカウント情報 (id, username, etc.)
- `player_resources`: プレイヤーごとの資源所持量 (player_id, resource_type, amount)
- `player_achievements`: プレイヤーごとの実績達成状況 (player_id, achievement_id, unlocked_at)
- `player_permanent_upgrades`: プレステージ等による永続アップグレード (player_id, upgrade_id, level)

### データ更新の原子性（アトミック性）

複数のテーブルにまたがる更新処理は、必ず**データベースのトランザクション**内で行ってください。これにより、処理の途中でエラーが発生してもデータが不整合な状態になることを防ぎます。

## 3. 具体例：プレステージ処理

プレステージを実行する際、サーバーは以下の処理を**単一のトランザクション**として実行する必要があります。

```sql
BEGIN; -- トランザクション開始

-- 1. これからリセットされる資源量を取得し、PPを計算する (アプリケーションロジック)
-- const pp_to_add = calculate_pp(current_resources);

-- 2. 進行状況をリセットする
DELETE FROM player_resources WHERE player_id = ?;
DELETE FROM player_celestial_bodies WHERE player_id = ?;
-- ... 他のリセット対象テーブルも同様

-- 3. 永続データを更新する
-- プレステージポイントを加算
UPDATE player_permanent_stats SET prestige_points = prestige_points + ? WHERE player_id = ?;
-- プレステージ回数をインクリメント
UPDATE player_permanent_stats SET prestige_count = prestige_count + 1 WHERE player_id = ?;

COMMIT; -- 全ての処理が成功したら確定
```

もし途中でいずれかのSQLが失敗した場合、`ROLLBACK`によって全ての変更が取り消され、データの一貫性が保たれます。

## 4. WBSへの適用

- **Phase 1 (実績):** `player_achievements` テーブルを設計・実装する。
- **Phase 2 (プレステージ):** `player_permanent_stats`のような永続データを管理するテーブルを設計し、リセット処理をトランザクション化する。
