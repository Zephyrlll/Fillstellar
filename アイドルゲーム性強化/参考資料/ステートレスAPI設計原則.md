# ステートレスAPI設計原則

## 1. 基本原則

**サーバーはクライアントの状態を覚えない。**

各APIリクエストは、それ自体で完結するために必要な全ての情報を含んでいるべきです。サーバーは、前のリクエストの内容を覚えておく必要がありません。これを「ステートレス」と呼びます。

## 2. なぜ重要か？

- **スケーラビリティ:** サーバー側に状態がないため、リクエストを複数のサーバーに簡単に分散（ロードバランシング）できます。将来のユーザー増加に対応しやすくなります。
- **信頼性:** サーバーがクラッシュしても、クライアントの状態（セッション情報など）が失われることがありません。
- **シンプルさ:** サーバー側のロジックが「リクエストを受け取り、処理し、返す」という単純なサイクルになり、複雑さが軽減されます。

## 3. 実装ガイドライン

### 認証にはトークンを使用する

プレイヤーを識別するために、サーバーセッションではなく、**認証トークン（例: JWT - JSON Web Token）** を使用します。

1.  **ログイン時:** プレイヤーがログインに成功したら、サーバーは暗号化したユーザー情報を含むトークンを生成してクライアントに返します。
2.  **リクエスト時:** クライアントは、それ以降の全てのリクエストのヘッダーにこのトークンを付与して送信します。
3.  **サーバー処理時:** サーバーはリクエストを受け取ると、まずヘッダーのトークンを検証し、どのプレイヤーからのリクエストであるかを判断します。

### APIエンドポイントの設計

- **NG (ステートフルな設計):**
  - `POST /upgrades/buy`
  - この場合、サーバーはセッション情報から「誰が」購入しようとしているのかを知る必要があります。

- **OK (ステートレスな設計):**
  - `POST /players/{playerId}/upgrades`
  - `POST /my/upgrades` (トークンから自分のIDを特定)
  - リクエストには、**「誰が (Who)」**（トークンから判別）と**「何を (What)」**（リクエストボディやパスパラメータ）が常に含まれています。

## 4. 具体例：Rust/Actix Webでの実装

Actix Webのミドルウェアやエクストラクタを使えば、トークンの検証を綺麗に実装できます。

```rust
// `user`はトークンから抽出されたプレイヤー情報
async fn get_my_resources(user: User) -> impl Responder {
    // トークンのおかげで、どのユーザーの資源を取得すればよいか分かる
    let resources = db::get_resources_for_player(user.id).await;
    HttpResponse::Ok().json(resources)
}

// ルーティング設定
App::new()
    .service(
        web::scope("/my")
            .wrap(JwtAuthMiddleware) // このスコープ以下の全エンドポイントでトークン検証
            .route("/resources", web::get().to(get_my_resources))
    );
```
